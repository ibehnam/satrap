"""Phrase generation and persistence for Satrap git worktrees.

Satrap names worktree directories using a short, human-readable slug of the form
`word-word-word`. A phrase is generated by sampling three words with `secrets.choice()`
from a dictionary word list, lowercasing them, and joining with hyphens. Words are
filtered to be alphabetic-only (`str.isalpha`) and length-bounded (3..12 characters) to
avoid whitespace and punctuation and to produce path-friendly components.

Dictionary sourcing
- By default, this module uses the first existing system dictionary found in:
  `/usr/share/dict/words`, `/usr/share/dict/web2`, or `/usr/dict/words`.
- Callers may override dictionary selection via `words_path` (useful for tests or
  nonstandard environments).
- If no dictionary is found, phrase generation fails with `FileNotFoundError`. If the
  filtered dictionary is too small (< 1000 words), generation fails with `RuntimeError`
  to avoid excessive collision probability.

Uniqueness guarantees
- Uniqueness is enforced against a persisted ledger at `phrases_path` (typically
  `<control_root>/phrases.txt`), loaded into memory as a set.
- The generator retries random draws until it finds a phrase not present in the ledger,
  then persists the updated set and returns the new phrase.
- This is best-effort within a single process. There is no cross-process locking and
  persistence is a read-modify-write overwrite, so concurrent runs may produce duplicates
  or lose updates.

Persistence format (`phrases.txt`)
- UTF-8 text file, one phrase per line.
- On read: lines are stripped; blank lines are ignored.
- On write: the file is rewritten as a sorted set of phrases and always ends with a
  trailing newline.

Limitations
- Output is intentionally non-deterministic; `secrets` is used for robust random selection
  but does not by itself provide a hard uniqueness guarantee.
- Phrase quality and character set depend on the host dictionary; uncommon or non-ASCII
  words may appear if they pass `isalpha()`.
- Performance scales with the size of the ledger (full-file load and rewrite), and
  generation gives up after 10,000 attempts if collisions persist.
"""

from __future__ import annotations

import secrets
from pathlib import Path


_DICT_CANDIDATES = [
    Path("/usr/share/dict/words"),
    Path("/usr/share/dict/web2"),
    Path("/usr/dict/words"),
]


def generate_unique_phrase(*, phrases_path: Path, words_path: Path | None = None) -> str:
    """Return a unique `word-word-word` phrase and persist it to `phrases_path`.

    Uses the system dictionary on macOS when available. Uniqueness is best-effort and does not
    implement cross-process locking (placeholder for future concurrency hardening).
    """
    phrases_path.parent.mkdir(parents=True, exist_ok=True)
    existing = _load_existing_phrases(phrases_path)

    words = _load_words(words_path or _find_dictionary())
    if len(words) < 1000:
        raise RuntimeError("Dictionary word list too small; cannot generate phrases reliably.")

    for _ in range(10_000):
        phrase = "-".join(secrets.choice(words) for _ in range(3))
        if phrase in existing:
            continue
        phrases_path.write_text("\n".join(sorted(existing | {phrase})) + "\n", encoding="utf-8")
        return phrase

    raise RuntimeError("Failed to generate a unique 3-word phrase after many attempts.")


def _find_dictionary() -> Path:
    for p in _DICT_CANDIDATES:
        if p.exists() and p.is_file():
            return p
    raise FileNotFoundError("No system dictionary found (tried /usr/share/dict/words and common alternatives).")


def _load_existing_phrases(path: Path) -> set[str]:
    if not path.exists():
        return set()
    return {line.strip() for line in path.read_text(encoding="utf-8").splitlines() if line.strip()}


def _load_words(path: Path) -> list[str]:
    raw = path.read_text(encoding="utf-8", errors="ignore").splitlines()
    out: list[str] = []
    for w in raw:
        w = w.strip().lower()
        if not w:
            continue
        if not w.isalpha():
            continue
        if len(w) < 3 or len(w) > 12:
            continue
        out.append(w)
    return out
